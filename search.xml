<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Redis学习笔记]]></title>
    <url>%2F2019%2F06%2F12%2FRedis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_20190612%2F</url>
    <content type="text"><![CDATA[Linux环境下Redis的安装编译安装 一种类似一维数组的对象，由一组数据及相关的索引组成。 tar -zxvf redis-3.2.8.tar.gz cd redis-3.2.8 make &amp;&amp; make test 安装到指定目录： make install PREFIX=/usr/local/bin 安装过程可能出现的错误一： 解决方案： yum install gcc 安装过程可能出现的错误二： 解决方案： make MALLOC=libc 安装过程可能出现的错误三： 解决方案： wget http://downloads.sourceforge.net/tcl/tcl8.6.1-src.tar.gz tar -xzvf tcl8.6.1-src.tar.gz cd /usr/local/tcl8.6.1/unix/ ./configure make &amp;&amp; make install Redis生产环境启动方案： 将redis_init_script脚本拷贝到linux的/etc/init.d目录中，并重命名为redis_6379 cp /opt/redis-5.0.5/utils/redis_init_script /etc/init.d/redis_6379 修改redis_6379脚本的第6行的REDISPORT，设置为相同的端口号（默认就是6379） 创建目录： mkdir /etc/redis（存放redis的配置文件） mkdir /var/redis/6379（存放redis的持久化文件） 修改redis配置文件（默认在根目录下，redis.conf），拷贝到/etc/redis目录中，修改名称为6379.conf cp redis.conf /etc/redis/6379.conf 修改redis.conf中的部分配置为生产环境 --让redis以daemon（后台守护进程）进程运行 daemonize yes --设置redis的pid文件位置 pidfile /var/run/redis_6379.pid --设置redis的监听端口号 port 6379 --设置持久化文件的存储位置 dir /var/redis/6379 启动redis cd /etc/init.d chmod 777 redis_6379 ./redis_6379 start 确认redis进程是否启动 ps -ef | grep redis 让redis跟随系统启动自动启动 # chkconfig: 2345 90 10 # description: Redis is a persistent key-value database chkconfig redis_6379 on redis cli的使用 编译后，进入cd /usr/loacl/bin下可看到redis-cli redis-cli SHUTDOWN，连接本机的6379端口停止redis进程 redis-cli -h 127.0.0.1 -p 6379 SHUTDOWN，制定要连接的ip和端口号 redis-cli PING，ping redis的端口，看是否正常 redis-cli，进入交互式命令行 SET k1 v1 GET k1]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jupyter NoteBook使用介绍]]></title>
    <url>%2F2019%2F05%2F08%2Fjupyter-notebook%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D20190114%2F</url>
    <content type="text"><![CDATA[设置工作目录 Anaconda安装完成后，自带了Jupyter NoteBook，初次启动可能会出现如下错误：出现原因是：未安装nodejs造成的，安装后。该错误解决。 安装成功后默认的Jupyter NoteBook设置查看如下，点击Jupyter NoteBook右键属性： 【目标T】：C:\Anaconda3\python.exe C:\Anaconda3\cwp.py C:\Anaconda3 C:\Anaconda3\python.exe C:\Anaconda3\Scripts\jupyter-notebook-script.py %USERPROFILE% 【起始位置】：C:\Users\Administrator 默认设置的工作目录是C:\Users\Administrator下，参考了网上说的 修改默认工作目录的方法，最简单的是按以下实现： 【目标T】：C:\Anaconda3\Scripts\jupyter-notebook.exe 【起始位置】：E:\Jupyter （该目录需要提前创建）按以上设置完后启动后，工作目录就设置为E盘下。 主题的安装 jupyterthemes的官方下载地址可通过如下命令安装：pip install jupyterthemes==0.13.6 我想安装的主题是monokai，通过执行以上命令后，发现没有monokai主题模板。通过查看网上其他安装方法，最终按以下方式执行成功： cd /d C:\Anaconda3\Scripts pip install jupyter-themer 安装成功后，查看目前的主题模板，并执行monokai的设置： jt -l //可查看如下模板信息： chesterish grade3 gruvboxd gruvboxl monokai oceans16 onedork solarizedd solarizedl //设置monokai模板主题 jt -t monokai -f dejavu -fs 12 -T 参考链接：Jupyter Notebook介绍、安装及使用教程 在安装过程中会出现pip版本过低和jt -l命令无效。需要执行以下命令： python -m pip install --upgrade pip pip install --upgrade jupyterthemes]]></content>
      <categories>
        <category>工具介绍</category>
      </categories>
      <tags>
        <tag>日常笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack基础入门]]></title>
    <url>%2F2019%2F02%2F27%2FwebPack_20190227%2F</url>
    <content type="text"><![CDATA[webpack介绍webpack：是一个前端资源的打包工具，它可以将js、image、css等资源当成一个模块进行打包。 ###webpack的优点： 模块化开发 编译typescript、ES6等高级语法 CSS预编译 ###webpack的缺点： 配置繁琐，文档不丰富 webpack的安装 安装node.js 下载地址：https://nodejs.org/en/download/ 安装成功后，在command下输入：node -v 确认是否安装成功 安装npmnpm：Node Package Manage，node包管理和分发的工具，可以对应用的依赖进行管理，类似Maven工具。可以通过npm方便地下载js库，打包js文件。node.js已集成了npm工具，可通过npm -v 查看当前版本。 查看配置信息： npm config ls 运行结果： metrics-registry = &quot;https://registry.npmjs.org/&quot; scope = &quot;&quot; user-agent = &quot;npm/6.4.1 node/v10.14.2 win32 x64&quot; ; userconfig C:\Users\yang.zhongming\.npmrc prefix = &quot;C:\\Users\\Administrator\\AppData ; node bin location = D:\Program Files\nodejs\node.exe cwd = C:\Users\Administrator HOME = C:\Users\Administrator &quot;npm config ls -l&quot; to show all defaults. 设置包路径：默认的包管理路径： C:\Users\Administrator\AppData\Roaming\npm\node_modules 修改包路径：在node.js的安装目录下创建npm_modules和npm_cache -- 设置路径 npm config set prefix &quot;D:\Program Files\nodejs\npm_modules&quot; npm config set cache &quot;D:\Program Files\nodejs\npm_cache&quot; -- 查看路径 npm config ls ; cli configs metrics-registry = &quot;https://registry.npmjs.org/&quot; scope = &quot;&quot; user-agent = &quot;npm/6.4.1 node/v10.14.2 win32 x64&quot; ; userconfig C:\Users\Administrator\.npmrc cache = &quot;D:\\Program Files\\nodejs\\npm_cache&quot; prefix = &quot;D:\\Program Files\\nodejs\\npm_modules&quot; ; builtin config undefined ; node bin location = D:\Program Files\nodejs\node.exe ; cwd = D:\Program Files\nodejs ; HOME = C:\Users\Administrator ; &quot;npm config ls -l&quot; to show all defaults. 安装cnpm国内镜像，通常使用淘宝镜像来安装cnpm npm install -g cnpm --registry=https://registry.npm.taobao.org -- 查看安装版本 cnpm -v -- 版本信息 cnpm@6.0.0 (D:\Program Files\nodejs\npm_modules\node_modules\cnpm\lib\parse_argv.js) npm@6.9.0 (D:\Program Files\nodejs\npm_modules\node_modules\cnpm\node_modules\npm\lib\npm.js) node@10.14.2 (D:\Program Files\nodejs\node.exe) npminstall@3.20.2 (D:\Program Files\nodejs\npm_modules\node_modules\cnpm\node_modules\npminstall\lib\index.js) prefix=D:\Program Files\nodejs\npm_modules win32 x64 6.1.7601 registry=https://registry.npm.taobao.org 安装nrm 安装webpackwebpack安装分为本地安装和全局安装，本地安装是将webpack安装在当前项目的node_modules目录中，仅对当前项目有效。全局安装类似系统安装，对所有项目有效。 本地安装： cd 工程目录 npm install --save webpack npm install --save-dev webpack-cli（(4.0以后的版本需要安装webpack-cli） 全局安装webpack的js包下载到npm的包路径下 npm install webpack -g 指定版本安装 cnpm install --save-dev webpack@3.6.0 安装执行以下命令，确认是否安装成功 webpack 出现以下信息证明安装成功： No configuration file found and no output filename configured via CLI option. A configuration file could be named &apos;webpack.config.js&apos; in the current directory. Use --help to display the CLI options. webpack的打包分模块开发： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:v-bind=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;vue.js 入门程序&lt;/title&gt; &lt;script src=&quot;./js/vue.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;a v-bind:href=&quot;url&quot;&gt;&lt;span v-text=&quot;name&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;input type=&quot;text&quot; v-model=&quot;num1&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;num2&quot;&gt; = &lt;span v-text=&quot;result&quot;&gt;&lt;/span&gt; &lt;button v-on:click=&quot;change&quot;&gt;计算&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue({ el:&quot;#app&quot;, data:{name:&quot;计算器&quot;, num1:0, num2:0, result:0, url:&apos;http://www.baidu.com&apos; }, methods:{ change:function () { this.result = Number.parseInt(this.num1) + Number.parseInt(this.num2) alert(this.result) } } }); &lt;/script&gt; &lt;/html&gt; 对上述源代码进行分模块开发： 模块model.js的创建： //子模块使用的方法 var add = function (x,y){ return x + y; } //导出方法,module固定关键字 module.exports.add = add; //多个方法导出参考如下写法： module.exports = {add1,add2}; 主程序main.js的创建： var {add} = require(&quot;./model01.js&quot;); var Vue = require(&quot;./vue.min.js&quot;); var VM = new Vue({ el:&apos;#app&apos;, data:{ name:&apos;yzhm&apos;, num1:0, num2:1, url:&apos;http://www.baidu.com&apos;, }, methods:{ change:function() { this.result = add(Number.parseInt(this.num1),Number.parseInt(this.num2)) } } }); webpack打包： cd js文件夹 webpack main.js build.js 执行后显示如下： 原因是webpack版本过高，打包命令修改为： webpack main.js -o build.js 修改主画面： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:v-bind=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;vue.js 入门程序&lt;/title&gt; &lt;script src=&quot;./js/build.js&quot;&gt; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;a v-bind:href=&quot;url&quot;&gt;&lt;span v-text=&quot;name&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;input type=&quot;text&quot; v-model=&quot;num1&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;num2&quot;&gt; = &lt;span v-text=&quot;result&quot;&gt;&lt;/span&gt; &lt;button v-on:click=&quot;change&quot;&gt;计算&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; --注：主画面中引用的如下代码，应放在&lt;/body&gt;&lt;/html&gt;之间，否则可能会出现引用无效的情况。 &lt;script src=&quot;./js/build.js&quot;&gt; webpack-dev-server介绍webpack-dev-server开发服务器，它的功能可以实现热加载 并且自动刷新浏览器。 webpack的安装npm install webpack@3.6.0 webpack-dev-server@2.9.1 html-webpack-plugin@2.30.1 --save-dev 安装完成，会发现程序目录出现一个package.json文件，此文件中记录了程序的依赖。 { &quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack-dev-server --inline --hot --open --port 5008&quot; }, &quot;devDependencies&quot;: { &quot;html-webpack-plugin&quot;: &quot;^2.30.1&quot;, &quot;webpack&quot;: &quot;^3.6.0&quot;, &quot;webpack-dev-server&quot;: &quot;^2.9.1&quot; } } 参数说明： --inline：自动刷新 --hot：热加载 --port：指定端口 --open：自动在默认浏览器打开 --host：可以指定服务器的 ip，不指定则为127.0.0.1，如果对外发布则填写公网ip地址 devDependencies：开发人员在开发过程中所需要的依赖。 scripts：可执行的命令 ###配置webpack.config.js webpack.config.js是webpack的配置文件。在此文件中可以配置应用的入口文件、输出配置、插件等，其中要实现热加载自动刷新功能需要配置html-webpack-plugin插件。 html-webpack-plugin的作用是根据html模板在内存生成html文件，它的工作原理是根据模板文件在内存中生成一个index.html文件 配置模板文件： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;vue.js常用指令的测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--实现在body区域显示一个传智播客名称--&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--相当于MVVM的view视图--&gt; &lt;!--{{name}}--&gt; &lt;a v-bind:href=&quot;url&quot;&gt; &lt;span v-text=&quot;name&quot;&gt;&lt;/span&gt; &lt;/a&gt; &lt;input type=&quot;text&quot; v-model=&quot;num1&quot;/&gt; + &lt;input type=&quot;text&quot; v-model=&quot;num2&quot;/&gt;= &lt;!-- &lt;span v-text=&quot;Number.parseInt(num1)+Number.parseInt(num2)&quot;&gt;&lt;/span&gt;--&gt; &lt;span v-text=&quot;result&quot;&gt;&lt;/span&gt; &lt;!--{{Number.parseInt(num1)+Number.parseInt(num2)}}--&gt; &lt;button v-on:click=&quot;change&quot;&gt;计算&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 以上代码已去掉引入的script标签，即引入的build.js 配置 html-webpack-plugin,在webpack.config.js中配置html-webpack-plugin插件： //引用html-webpack-plugin插件，作用是根据html模板在内存生成html文件，它的工作原理是根据模板文件在内存中生成一个index.html文件。 var htmlwp = require(&apos;html-webpack-plugin&apos;); module.exports={ entry:&apos;./src/main.js&apos;, //指定打包的入口文件 output:{ path : __dirname+&apos;/dist&apos;, // 注意：__dirname表示webpack.config.js所在目录的绝对路径 filename:&apos;build.js&apos; //输出文件 }, devtool: &apos;eval-source-map&apos;, plugins:[ new htmlwp({ title: &apos;首页&apos;, //生成的页面标题&lt;head&gt;&lt;title&gt;首页&lt;/title&gt;&lt;/head&gt; filename: &apos;index.html&apos;, //webpack-dev-server在内存中生成的文件名称，自动将build注入到这个页面底部，才能实现自动刷新功能 template: &apos;vue_02.html&apos; //根据vue_02.html这个模板来生成(这个文件请程序员自己生成) }) ] } 启动 使用webstorm，右键package.json文件，选择“Show npm Scripts” 双击dev,自动打开浏览器 debug调试 在webpack.config.js中配置，参照上述完整配置： devtool: &apos;eval-source-map&apos; 在add方法中添加debugger，例如： // 定义add函数 function add(x, y) { debugger return x + y }]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoDB安装及操作]]></title>
    <url>%2F2019%2F02%2F18%2FmongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_20190218%2F</url>
    <content type="text"><![CDATA[mongoDB简介mongodb：MongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。 mongoDB的安装 官方下载地址：https://www.mongodb.com/安装成功后，生成的默认目录为：mongoDB4.0的版本安装后，默认安装目录下是没有 mongo.conf文件的 注册 MongoDB服务：默认情况下，MongoDB4.0服务在安装过程中是已经注册的，如果没有注册可以通过以下命令，完成注册： mongod –dbpath D:\Program Files\MongoDB\Server\4.0\data\db –logpath D:\Program Files\MongoDB\Server\4.0\log\mongo.log –logappend –serviceName MongoDB –auth –install 3.0的版本是通过以下命令进行注册的： mongod.exe ‐‐config &quot;d:\MongoDB\Server\3.4\mongo.conf&quot; ‐‐install 启动服务 net start MongoDB 关闭服务 net stop MongoDB mongoDB的配置 mongoDB4.0的版本安装后，默认安装目录下是没有 mongo.conf文件的 安装成功后，可以通过IE浏览器查看是否启动： 通过命令行方式查看是否启动： mongoDB的入门操作 连接mongoDB 数据库操作 查询数据库show dbs 运行结果：admin 0.000GB config 0.000GB local 0.000GB 查看当前数据库db 运行结果：test 创建数据库 use test 如果当前数据库不存在则创建，如果存在则切换至该数据库。 删除数据库 db.dropDatabase() 集合操作 创建集合db.createCollection(name, options) db.createCollection(&apos;student&apos;) options属性参考： 删除集合db.student.drop() 插入文档 db.COLLECTION_NAME.insert(document) db.student.insert({“name”:&quot;yzhm&quot;}) 运行结果： { &quot;_id&quot; : ObjectId(&quot;5c6a6c7112affd29ce87795c&quot;), &quot;name&quot; : &quot;yzhming&quot; } 查询文档db.collection.find(query, projection) db.student.find() 运行结果：{ &quot;_id&quot; : ObjectId(&quot;5c6a6c7112affd29ce87795c&quot;), &quot;name&quot; : &quot;yzhming&quot; } 更新文档 删除文档 创建用户 查询用户 修改用户 修改密码 删除用户 参考教程：[http://www.runoob.com/mongodb/mongodb-query.html]]]></content>
      <categories>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>数据库，NoSQL，mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NumPy学习笔记]]></title>
    <url>%2F2019%2F01%2F29%2FNumPy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_20190129%2F</url>
    <content type="text"><![CDATA[NumPy简介NumPy：Numerical Python,是python进行科学计算的一个基础包。 NumPy的数据结构ndarry：N-dimensional array,一种由相同类型的元素组成的多维数组对象。 元素的数据类型由dtpye(data-type)对象来指定，每个ndarry只有一种dtype类型。 大小固定，创建好数组时一旦指定好大小，不会再发生改变 ndarry的创建 array函数：将序列转换成ndarry //通过array函数创建 data1 = [0,1,2,3,1.1] arr1 = np.array(data1) 运行结果： array([0. , 1. , 2. , 3. , 1.1]) 嵌套序列创建： //通过嵌套序列创建 data2 = [[1,2,3],[4,5,6]] arr2 = np.array(data2) 运行结果： array([[1, 2, 3], [4, 5, 6]]) zeros函数：创建指定长度的全零数组 np.zeros(10) 运行结果： array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]) 创建多维： np.zeros((3,4)) 运行结果： array([[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.]]) ones函数：创建指定长度的全1数组 np.ones(10) 运行结果： array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]) 创建多维： np.ones((2,3)) 运行结果： array([[1., 1., 1.], [1., 1., 1.]]) empty函数：创建一个没有具体值的数组，通常都是一些未初始化的垃圾值np.empty(5) 运行结果：array([0. , 1. , 2. , 3. , 1.1]) 创建多维：np.empty((2,2,3)) 运行结果：array([[[0., 0., 0.], [0., 0., 0.]], [[0., 0., 0.], [0., 0., 0.]]]) arange函数：类似range函数，通过开始值、终值和步长创建数组。创建的数组不包含终值值。np.arange(10) 运行结果：array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 根据起始值，步长创建：np.arange(1,10,1) 运行结果:array([1, 2, 3, 4, 5, 6, 7, 8, 9]) linspace函数：通过指定开始值、终值和元素个数来创建一维数组，可以通过endpoint关键字指定是否包括终值，缺省设置是包括终值np.linspace(1,10,5) 运行结果：array([ 1. , 3.25, 5.5 , 7.75, 10. ]) logspace函数：和linspace类似，用来创建等比数列np.logspace(0,2,5) 运行结果：array([ 10. , 17.7827941 , 31.6227766 , 56.23413252, 100. ]) random函数：随机创建数组 np.random.random(10) 运行结果： array([0.60751347, 0.29262802, 0.48379076, 0.06987773, 0.09515098, 0.1943465 , 0.46335728, 0.46320678, 0.81314993, 0.51329606]) 通过设置参数创建： np.random.random((2,2,3)) 运行结果： array([[[0.06608054, 0.55363782, 0.62406291], [0.77318127, 0.58557065, 0.17148664]], [[0.79126153, 0.83586225, 0.59518475], [0.60087036, 0.13638575, 0.7900084 ]]]) ndarry的属性 ndim:维度数量arr1.ndim 运行结果：1 shape：表示各维度大小的元组arr2.shape 运行结果：(2, 3) dtype：元素数据类型arr2.dtype 运行结果：dtype(&apos;int32&apos;) size：元素总个数m*narr2.size 运行结果：6 ndarry的数据类型创建数组时，可以通过dtype显式指定数据类型，如不指定NumPy会根据数据默认指定。例： data3 = np.array([1,2,3,4,5]) data3.dtype 运行结果： dtype(&apos;int32&apos;) astype函数：数据类型转换 data4 = data3.astype(float) data4.dtype 运行结果： dtype(&apos;float64&apos;) 数组与标量、数组直接的运算 矢量化:不需要编写循环，可实现对数据的批量计算。性能上比Python快一两个数量级，大小相等的任何算术运算都会应用到元素级。 数组与标量之间的运算 arr1 = np.array([1,2,3,4,5]) arr1+2 运行结果： array([3, 4, 5, 6, 7]) 除法运算： from __future__ import division 1/arr1 运行结果： array([1. , 0.5 , 0.33333333, 0.25 , 0.2 ]) 大小相等数组之间的运算 arr2 = ([5,6,7,8,9]) arr1+arr2 运行结果： array([ 6, 8, 10, 12, 14]) 例1 arr3 = np.array([[1,2,3],[4,5,6]]) arr4 = np.array([[1,2,3],[4,5,6]]) arr3 + arr4 运行结果： array([[ 2, 4, 6], [ 8, 10, 12]]) 例2 arr3 - arr4 运行结果： array([[0, 0, 0], [0, 0, 0]]) 例3 arr3 * arr4 运行结果： array([[ 1, 4, 9], [16, 25, 36]]) 例4 arr3 / arr4 运行结果： array([[1., 1., 1.], [1., 1., 1.]]) 数组的矩阵积 矩阵积：不是元素级的运算，两个二维（多维）矩阵，第一个矩阵的列数与第二个矩阵的行数相同，可以进行矩阵乘法，即矩阵积。 设A为的m×p的矩阵，B为p×n的矩阵，那么称m×n的矩阵C为矩阵A与B的乘积，记作C=AB，其中矩阵C中的第i行第j列元素可以表示为： arr1 = np.array([[1,2,3],[1,2,3]]) arr2 = np.array([[1,2],[1,1],[2,1]]) arr1.dot(arr2) 运行结果： array([[9, 7], [9, 7]])]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python，NumPy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pandas学习笔记]]></title>
    <url>%2F2019%2F01%2F15%2FPandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_20190115%2F</url>
    <content type="text"><![CDATA[Pandas数据结构pandas的主要数据结构：Series和DataFarme Series 一种类似一维数组的对象，由一组数据及相关的索引组成。 #创建 obj1 = Series([9,-1,7,6],index=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]) obj1 运行结果： a 9 b -1 c 7 d 6 dtype: int64 通过字典的方式创建： data = {&apos;a&apos;:1,&apos;b&apos;:2,&apos;c&apos;:3,&apos;d&apos;:4} obj2 = Series(data) obj2 运行结果： a 1 b 2 c 3 d 4 dtype: int64 通过列表形成创建： data = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;] obj3 = Series(data) obj3 运行结果： 0 a 1 b 2 c 3 d dtype: object 通过列表作为索引创建匹配，以indx值为索引去匹配查找data中的值，索引中未找到值的以NaN表示。data中多余的值不显示。 data = {&apos;a&apos;:1,&apos;b&apos;:2,&apos;c&apos;:3,&apos;d&apos;:4} indx = [&apos;a&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;] obj4 = Series(data,index=indx) obj4 运行结果： a 1.0 c 3.0 d 4.0 e NaN dtype: float64 Series在运算中会自动对齐不同的索引的数据： obj2+ojb4 运算结果： a 2.0 b NaN c 6.0 d 8.0 e NaN dtype: float64]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python，Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于学习]]></title>
    <url>%2F2019%2F01%2F10%2F%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A020190110%2F</url>
    <content type="text"><![CDATA[今天读了一篇关于讨论学习的文章，感觉受益匪浅。文章从以下几个方面阐述了如何理解学习： 知识的错觉 我知道了≠我懂了： 看自己是不是真懂一件事，通常追问3个有深度的问题，就能辨别自己是否真正懂了。 把类似的为什么放在学过的领域，再试着多追问两三个问题，就能发现不少错觉了。 知识的分类 比起直接学习，先明确学的是什么，对知识进行分类效果要更好。按知识的分类，分为以下几类： 事实知识 | 2018年中国的GDP是多少 概念知识 | GDP指标的含义、概念 程序知识 | GDP如何计算 元认知知识 | GDP属于宏观经济学的重要组成部分。理解研究GDP的意义：为了更好地衡量、评估、分析一个经济的生成力。 仅仅学习事实性、概念性的知识意义并不大，可以完全在网上搜索解决，而且被直接应用的范围比较小。大部分人陷入了这两者的泛泛学习。 程序认识、元认识认识对于我们价值更大，需要多花功夫钻研。 理解学习 加强实践和输出，学完后马上用、马上教别人 主动学习（输出）&gt; 被动学习（输入） 系统地学习 通过碎片化学习的知识，拼接成更完整的网，形成自己的知识体系，达到真的懂，真能用，才可能因为学多了拥有迁移思考的能力，解决更多的问题。 建立自己的多元学科模型 人的格局不同，差距很大；人和人的差别，在于认知。只有元知识不断升级，才能让自己的整个知识体系更完善、更广博。 查理·芒格的“多学科思维模型”指出：我坚信几乎所有聪明人都有一套思维模型的框架。有了那个体系之后，你就能逐渐提高对事物的认识。 芒格比较推崇的思维模型– 复利原则 / 排列组合原理 / 费马帕斯卡系统 / 决策树理论 /会记学 / 复式簿记 / 质量控制理论 / 后备系统 / 断裂点理论 / 理解质量概念 / 误判心理学 / 微观经济学 / 规模优势理论]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>生活随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再见，2018]]></title>
    <url>%2F2018%2F12%2F31%2F%E5%86%8D%E8%A7%81%EF%BC%8C2018%2F</url>
    <content type="text"><![CDATA[2018年的最后一天，独自坐在灯下迎接2019年的到来。时间过的有多么快，快的让人都来不及遐想，这一年就这么匆匆结束了。 2017年此时的种种经历仍挥之不去，如今已马上要跨入了2019年了。就好像做了个梦似的，一觉醒来已经经历了太多的时间轮回。 再见，2018，回想这一年收获了多少，总感觉还有太多太多的事没来得及做，就这样匆匆结束了。唯一收获的是，这一年有了些许白发，不得不承认岁月催人老。随着时光的流逝，我们已渐渐老去，经历的那些年，那些事，也逐渐尘封在人生的岁月里。 你好，2019，经过这些天的折腾，唯一欣慰的是属于自己的网站终于在2019年开通了。2018年已这样的方式结束，2019年已这样的方式开始，希望在未来的日子里每一天都能收获满满。今天看了一篇文章，就以此为志，迎接2019年人生新的阶段。]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>生活随笔</tag>
      </tags>
  </entry>
</search>
